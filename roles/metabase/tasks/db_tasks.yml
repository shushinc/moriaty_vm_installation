---
- name: Ensure MySQL Python driver is present
  package:
    name: python3-PyMySQL
    state: present

- name: Ensure MySQL service is started and enabled
  service:
    name: mysqld
    state: started
    enabled: yes

# NEW: unzip is required to extract the SQL from the zip archive
- name: Ensure unzip is installed
  package:
    name: unzip
    state: present

- name: Resolve Metabase DB connection from dbs group
  set_fact:
    mb_db_name:  "{{ hostvars[groups['dbs'][0]].metabase_db_name | default(hostvars[groups['dbs'][0]].metabase_db_name) }}"
    mb_db_user:  "{{ hostvars[groups['dbs'][0]].metabase_db_user | default(hostvars[groups['dbs'][0]].db_user) }}"
    mb_db_pass:  "{{ hostvars[groups['dbs'][0]].metabase_db_password | default(hostvars[groups['dbs'][0]].db_password) }}"

- name: Show resolved Metabase DB connection values
  debug:
    msg:
      - "Metabase DB Name: {{ mb_db_name }}"
      - "Metabase DB User: {{ mb_db_user }}"
      - "Metabase DB Pass: {{ mb_db_pass }}"

- name: Check if Metabase DB exists
  community.mysql.mysql_query:
    query: "SHOW DATABASES LIKE '{{ mb_db_name }}';"
    login_user: root
  register: mb_db_check

- name: Show DB check result
  debug:
    var: mb_db_check.query_result

- name: Create Metabase database if missing
  community.mysql.mysql_db:
    name: "{{ mb_db_name }}"
    state: present
    login_user: root
  when: mb_db_check.query_result | length == 0 or (mb_db_check.query_result[0] | length == 0)

- name: Check if Metabase DB exists after DB creation
  community.mysql.mysql_query:
    query: "SHOW DATABASES LIKE '{{ mb_db_name }}';"
    login_user: root
  register: mb_db_check

- name: Show DB check result after DB creation
  debug:
    var: mb_db_check.query_result

- name: Ensure Metabase user for localhost
  community.mysql.mysql_user:
    name: "{{ mb_db_user }}"
    password: "{{ mb_db_pass }}"
    host: "localhost"
    priv: "{{ mb_db_name }}.*:ALL"
    plugin: "mysql_native_password"
    append_privs: true
    state: present
    login_user: root

- name: Ensure Metabase user for any host (%)
  community.mysql.mysql_user:
    name: "{{ mb_db_user }}"
    password: "{{ mb_db_pass }}"
    host: "%"
    priv: "{{ mb_db_name }}.*:ALL"
    append_privs: true
    state: present
    login_user: root

# === Changed section starts here ===

- name: Copy zipped SQL dump to destination server
  copy:
    src: "{{ role_path }}/templates/metabase_db.sql.zip"
    dest: "{{ sql_zip_path | default('/tmp/metabase_db.sql.zip') }}"
    mode: '0644'

# Extract into /tmp (idempotent if the .sql already exists)
- name: Unzip SQL dump
  ansible.builtin.unarchive:
    src: "{{ sql_zip_path | default('/tmp/metabase_db.sql.zip') }}"
    dest: "{{ sql_extract_dir | default('/tmp') }}"
    remote_src: true
    creates: "{{ sql_extract_dir | default('/tmp') }}/metabase_db.sql"

# If the archive layout is different, find the actual .sql file
- name: Find unzipped SQL file
  ansible.builtin.find:
    paths: "{{ sql_extract_dir | default('/tmp') }}"
    patterns: "metabase_db.sql"
    file_type: file
  register: found_sql

- name: Fail if SQL file not found after unzip
  ansible.builtin.assert:
    that:
      - found_sql.files | length > 0
    fail_msg: "metabase_db.sql not found after unarchive. Check archive contents."

- name: Import SQL dump into {{ mb_db_name }}
  community.mysql.mysql_db:
    name: "{{ mb_db_name }}"
    state: import
    target: "{{ found_sql.files[0].path }}"
    login_user: root

# (Optional) clean up the uploaded zip
# - name: Remove uploaded zip
#   file:
#     path: "{{ sql_zip_path | default('/tmp/metabase_db.sql.zip') }}"
#     state: absent


- name: Fix ONLY the Metabase app DB connection (do not touch Drupal)
  community.mysql.mysql_query:
    login_host: "{{ MB_DB_HOST }}"
    login_port: "{{ MB_DB_PORT | int }}"
    login_user: "{{ MB_DB_USER }}"
    login_password: "{{ MB_DB_PASS }}"
    login_db: "{{ MB_DB_DBNAME }}"
    query: >
      UPDATE metabase_database
      SET details = JSON_SET(
        details,
        '$.host',     '{{ MB_DB_HOST }}',
        '$.port',     CAST({{ MB_DB_PORT | int }} AS UNSIGNED),
        '$.dbname',   '{{ MB_DB_DBNAME }}',
        '$.user',     '{{ MB_DB_USER }}',
        '$.password', '{{ MB_DB_PASS }}'
      )
      WHERE name = 'metabase'
         OR JSON_EXTRACT(details,'$.dbname') = JSON_QUOTE('{{ MB_DB_DBNAME }}');


- name: Keep Drupal (moriarty) source pointed to the right DB/user (no-op if already correct)
  community.mysql.mysql_query:
    login_host: "{{ MB_DB_HOST }}"
    login_port: "{{ MB_DB_PORT | int }}"
    login_user: "{{ MB_DB_USER }}"
    login_password: "{{ MB_DB_PASS }}"
    login_db: "{{ MB_DB_DBNAME }}"
    query: >
      UPDATE metabase_database
      SET details = JSON_SET(
        details,
        '$.host',     '{{ MB_DB_HOST }}',
        '$.port',     CAST(3306 AS UNSIGNED),
        '$.dbname',   '{{ hostvars[groups['dbs'][0]].db_name }}',
        '$.user',     '{{ hostvars[groups['dbs'][0]].db_user }}',
        '$.password', '{{ hostvars[groups['dbs'][0]].db_password }}'
      )
      WHERE name = 'moriarty'
        AND (
          JSON_EXTRACT(details,'$.host')  <> JSON_QUOTE('{{ MB_DB_HOST }}')
          OR JSON_EXTRACT(details,'$.dbname') <> JSON_QUOTE('{{ hostvars[groups['dbs'][0]].db_name }}')
          OR JSON_EXTRACT(details,'$.user')   <> JSON_QUOTE('{{ hostvars[groups['dbs'][0]].db_user }}')
        );

- name: Verify saved connections
  community.mysql.mysql_query:
    login_host: "{{ MB_DB_HOST }}"
    login_port: "{{ MB_DB_PORT | int }}"
    login_user: "{{ MB_DB_USER }}"
    login_password: "{{ MB_DB_PASS }}"
    login_db: "{{ MB_DB_DBNAME }}"
    query: >
      SELECT id, name,
             JSON_UNQUOTE(JSON_EXTRACT(details,'$.host'))   AS host,
             JSON_UNQUOTE(JSON_EXTRACT(details,'$.dbname')) AS dbname,
             JSON_UNQUOTE(JSON_EXTRACT(details,'$.user'))   AS user
      FROM metabase_database;
  register: check_dbs

- name: Verify saved connections
  debug:
    var: check_dbs.query_result


- name: Flush privileges
  shell: "mysql -u root -e 'FLUSH PRIVILEGES;'"
  args:
    executable: /bin/bash
