---
- name: Set defaults for Metabase + replication vars
  set_fact:
    repl_user: "{{ repl_user | default('repl') }}"
    repl_password: "{{ repl_password | default('changeme') }}"
    metabase_db_name: "{{ metabase_db_name | default('metabase') }}"
    metabase_db_user: "{{ metabase_db_user | default('devportal') }}"
    metabase_db_password: "{{ metabase_db_password | default('pass') }}"
    metabase_app_hosts: "{{ metabase_app_hosts | default(['%','10.%']) }}"
    metabase_sql_dump_filename: "{{ metabase_sql_dump_filename | default('metabase_db.sql.gz') }}"
    mb_seed_local: "/tmp/metabase-seed-{{ metabase_db_name }}.sql.gz"


- name: (SELinux) Ensure tools present
  ansible.builtin.package:
    name: policycoreutils-python-utils
    state: present
  when: ansible_os_family == "RedHat"

- name: Install MySQL server and Python driver
  ansible.builtin.dnf:
    name:
      - mysql-server
      - python3-PyMySQL 
    state: present
    update_cache: yes

- name: Ensure unzip is installed
  package:
    name: unzip
    state: present

- name: Ensure MySQL data dir exists and owned by mysql
  ansible.builtin.file:
    path: /var/lib/mysql
    state: directory
    owner: mysql
    group: mysql
    mode: '0700'

- name: Restore SELinux contexts on MySQL paths
  ansible.builtin.command: restorecon -Rv /var/lib/mysql /etc/my.cnf /etc/my.cnf.d
  changed_when: false
  failed_when: false
  when: ansible_os_family == "RedHat"

- name: Set MySQL service name per OS
  set_fact:
    mysql_service_name: "{{ 'mysqld' if ansible_os_family == 'RedHat' else 'mysql' }}"


- name: Write /etc/my.cnf.d/server.cnf (GTID + ROW, per-role differences)
  ansible.builtin.copy:
    dest: /etc/my.cnf.d/server.cnf
    owner: root
    group: root
    mode: '0644'
    content: |
      {% set sid = (((inventory_hostname | hash('sha1'))[0:8] | int(base=16)) % 4294967294) + 1 %}
      [mysqld]
      server-id = {{ sid }}
      binlog_format = ROW
      gtid_mode = ON
      enforce_gtid_consistency = ON
      log_replica_updates = ON
      binlog_expire_logs_seconds = 2592000
      binlog_row_image = FULL
      {% if inventory_hostname in groups['db_primary'] %}
      # PRIMARY
      log_bin = mysql-bin
      innodb_flush_log_at_trx_commit = 1
      sync_binlog = 1
      {% else %}
      # REPLICA
      read_only = ON
      super_read_only = ON
      relay_log = relay-bin
      log_bin = mysql-bin
      {% endif %}
  register: server_cnf

- name: Restart mysqld if config changed
  service:
    name: mysqld
    state: restarted
  when: server_cnf.changed
  
- name: Ensure MySQL service is enabled and running
  ansible.builtin.service:
    name: mysqld
    state: started
    enabled: yes


- name: Create replication user (primary only)
  community.mysql.mysql_user:
    name: "{{ repl_user }}"
    host: "10.%"
    password: "{{ repl_password }}"
    priv: "*.*:REPLICATION SLAVE"
    plugin: mysql_native_password
    update_password: on_create
    state: present
    login_user: root
  when: inventory_hostname in groups['db_primary']

- name: Create Metabase database (primary only)
  community.mysql.mysql_db:
    name: "{{ metabase_db_name }}"
    state: present
    encoding: utf8mb4
    collation: utf8mb4_unicode_ci
    login_user: root
  when: inventory_hostname in groups['db_primary']

- name: Ensure Metabase user can connect from all allowed hosts (primary only)
  community.mysql.mysql_user:
    name: "{{ metabase_db_user }}"
    host: "{{ item }}"
    password: "{{ metabase_db_password }}"
    priv: "{{ metabase_db_name }}.*:ALL"
    plugin: mysql_native_password
    update_password: on_create
    state: present
    login_user: root
  loop: "{{ metabase_app_hosts }}"
  when: inventory_hostname in groups['db_primary']

- name: Copy Metabase SQL dump (ZIP) to PRIMARY
  ansible.builtin.copy:
    src: "{{ role_path }}/templates/metabase_db.sql.zip"
    dest: "{{ sql_zip_path | default('/tmp/metabase_db.sql.zip') }}"
    mode: "0644"
  when: inventory_hostname in groups['db_primary']

- name:  Unzip Metabase dump on PRIMARY
  ansible.builtin.unarchive:
    src: "{{ sql_zip_path | default('/tmp/metabase_db.sql.zip') }}"
    dest: "{{ sql_extract_dir | default('/tmp') }}"
    remote_src: true
    creates: "{{ sql_extract_dir | default('/tmp') }}/metabase_db.sql"
  when: inventory_hostname in groups['db_primary']


- name: Import Metabase dump into PRIMARY
  community.mysql.mysql_db:
    name: "{{ metabase_db_name }}"
    state: import
    target: /tmp/metabase_db.sql
    login_user: root
  when: inventory_hostname in groups['db_primary']


- name: Get Primary IP
  ansible.builtin.set_fact:
    primary_db_ip: "{{ hostvars[groups['db_primary'][0]].ansible_host | default(groups['db_primary'][0]) }}"
  when: inventory_hostname in groups['db_primary']

- name: Fix Metabase's internal connection to its OWN db (primary only)
  community.mysql.mysql_query:
    login_user: root
    login_db: "{{ metabase_db_name }}"
    query: >
      UPDATE metabase_database
      SET details = JSON_SET(
        details,
        '$.host',     '{{ primary_db_ip }}',
        '$.user',     '{{ metabase_db_user }}',
        '$.password', '{{ metabase_db_password }}'
      )
      WHERE name = 'metabase';
  when: inventory_hostname in groups['db_primary']
  # Add more queries here if you need to fix other connections (like 'moriarty')

# -----------------------------------------------------------------
# SECTION 5: Snapshot Primary & Seed Replicas (GTID Method)
# This logic is copied directly from your Drupal playbook.
# -----------------------------------------------------------------
- name: Create GTID-aware dump on PRIMARY
  ansible.builtin.shell: >
    mysqldump --single-transaction --quick --routines --triggers
    --master-data=2 --set-gtid-purged=ON
    --databases {{ metabase_db_name }} | gzip > /tmp/seed.sql.gz
  args:
    executable: /bin/bash
  when: inventory_hostname in groups['db_primary']

# - name: Ensure a local cache dir exists on controller
#   ansible.builtin.file:
#     path: "{{ mb_seed_local | dirname }}"
#     state: directory
#     mode: "0755"
#   delegate_to: localhost
#   when: inventory_hostname in groups['db_primary']

- name: Fetch seed dump to controller (/tmp)
  ansible.builtin.fetch:
    src: /tmp/seed.sql.gz
    dest: "{{ mb_seed_local }}"
    flat: true
  when: inventory_hostname in groups['db_primary']

# Optional: sanity check on controller
- name: Verify seed file is on controller (/tmp)
  ansible.builtin.stat:
    path: "{{ mb_seed_local }}"
  register: _mb_seed_local
  delegate_to: localhost
  when: inventory_hostname in groups['db_primary']


- name: Fail if local seed file is missing
  ansible.builtin.fail:
    msg: "Controller is missing the seed file: {{ mb_seed_local }}"
  when:
    - inventory_hostname in groups['db_primary']
    - not _mb_seed_local.stat.exists

- name: Push seed dump to REPLICAS
  ansible.builtin.copy:
    src: "{{ mb_seed_local }}"
    dest: /tmp/seed.sql.gz
    mode: "0644"
  when: inventory_hostname in groups['db_replicas']

- name: STOP REPLICA on replicas (ignore if clean)
  community.mysql.mysql_replication:
    mode: stopreplica
    login_user: root
  ignore_errors: yes
  when: inventory_hostname in groups['db_replicas']

- name: RESET REPLICA ALL and RESET MASTER (force clean GTIDs)
  community.mysql.mysql_query:
    login_user: root
    query:
      - "RESET REPLICA ALL"
      - "RESET MASTER"
  when: inventory_hostname in groups['db_replicas']

- name: Disable read_only/super_read_only on REPLICAS for initial import
  community.mysql.mysql_query:
    login_user: root
    query:
      - "SET GLOBAL super_read_only=OFF"
      - "SET GLOBAL read_only=OFF"
  when: inventory_hostname in groups['db_replicas']

- name: Ensure plain SQL exists on REPLICAS
  ansible.builtin.shell:
    cmd: "gunzip -c /tmp/seed.sql.gz > /tmp/seed.sql"
    creates: /tmp/seed.sql
  when: inventory_hostname in groups['db_replicas']

- name: Import plain SQL on REPLICAS (applies SET @@GLOBAL.GTID_PURGED)
  community.mysql.mysql_db:
    name: "{{ metabase_db_name }}"
    state: import
    target: /tmp/seed.sql
    login_user: root
  when: inventory_hostname in groups['db_replicas']

- name: Re-enable read_only/super_read_only on REPLICAS after import
  community.mysql.mysql_query:
    login_user: root
    query:
      - "SET GLOBAL read_only=ON"
      - "SET GLOBAL super_read_only=ON"
  when: inventory_hostname in groups['db_replicas']

# -----------------------------------------------------------------
# SECTION 6: Start and Verify Replication
# -----------------------------------------------------------------
- name: CHANGE PRIMARY (GTID) on replicas
  community.mysql.mysql_replication:
    mode: changeprimary
    master_host: "{{ hostvars[groups['db_primary'][0]].ansible_host | default(groups['db_primary'][0]) }}"
    master_user: "{{ repl_user }}"
    master_password: "{{ repl_password }}"
    master_port: 3306
    master_auto_position: yes
    login_user: root
  when: inventory_hostname in groups['db_replicas']

- name: START REPLICA on replicas
  community.mysql.mysql_replication:
    mode: startreplica
    login_user: root
  when: inventory_hostname in groups['db_replicas']

- name: Get replication status (replicas)
  community.mysql.mysql_replication:
    mode: getreplica
    login_user: root
  register: repl_status
  when: inventory_hostname in groups['db_replicas']

- name: Show replication summary (replicas)
  ansible.builtin.debug:
    msg:
      - "IO Thread Running: {{ repl_status.Replica_IO_Running }}"
      - "SQL Thread Running: {{ repl_status.Replica_SQL_Running }}"
      - "Last Error: {{ repl_status.Last_Error }}"
  when: inventory_hostname in groups['db_replicas']

- name: Fail if replica is broken
  ansible.builtin.fail:
    msg: "Replication is broken! IO or SQL thread is not 'Yes'."
  when:
    - inventory_hostname in groups['db_replicas']
    - (repl_status.Replica_IO_Running != 'Yes' or repl_status.Replica_SQL_Running != 'Yes')