---
- name: Ensure MySQL Python driver is present
  package:
    name: python3-PyMySQL
    state: present

- name: Ensure MySQL service is started and enabled
  service:
    name: mysqld
    state: started
    enabled: yes

# NEW: unzip is required to extract the SQL from the zip archive
- name: Ensure unzip is installed
  package:
    name: unzip
    state: present

- name: Resolve Metabase DB connection from dbs group
  set_fact:
    mb_db_name:  "{{ hostvars[groups['dbs'][0]].metabase_db_name | default(hostvars[groups['dbs'][0]].metabase_db_name) }}"
    mb_db_user:  "{{ hostvars[groups['dbs'][0]].metabase_db_user | default(hostvars[groups['dbs'][0]].db_user) }}"
    mb_db_pass:  "{{ hostvars[groups['dbs'][0]].metabase_db_password | default(hostvars[groups['dbs'][0]].db_password) }}"

- name: Show resolved Metabase DB connection values
  debug:
    msg:
      - "Metabase DB Name: {{ mb_db_name }}"
      - "Metabase DB User: {{ mb_db_user }}"
      - "Metabase DB Pass: {{ mb_db_pass }}"

- name: Check if Metabase DB exists
  community.mysql.mysql_query:
    query: "SHOW DATABASES LIKE '{{ mb_db_name }}';"
    login_user: root
  register: mb_db_check

- name: Show DB check result
  debug:
    var: mb_db_check.query_result

- name: Create Metabase database if missing
  community.mysql.mysql_db:
    name: "{{ mb_db_name }}"
    state: present
    login_user: root
  when: mb_db_check.query_result | length == 0 or (mb_db_check.query_result[0] | length == 0)

- name: Check if Metabase DB exists after DB creation
  community.mysql.mysql_query:
    query: "SHOW DATABASES LIKE '{{ mb_db_name }}';"
    login_user: root
  register: mb_db_check

- name: Show DB check result after DB creation
  debug:
    var: mb_db_check.query_result

- name: Ensure Metabase user for localhost
  community.mysql.mysql_user:
    name: "{{ mb_db_user }}"
    password: "{{ mb_db_pass }}"
    host: "localhost"
    priv: "{{ mb_db_name }}.*:ALL"
    plugin: "mysql_native_password"
    append_privs: true
    state: present
    login_user: root

- name: Ensure Metabase user for any host (%)
  community.mysql.mysql_user:
    name: "{{ mb_db_user }}"
    password: "{{ mb_db_pass }}"
    host: "%"
    priv: "{{ mb_db_name }}.*:ALL"
    append_privs: true
    state: present
    login_user: root

# === Changed section starts here ===

- name: Copy zipped SQL dump to destination server
  copy:
    src: "{{ role_path }}/templates/metabase_db.sql.zip"
    dest: "{{ sql_zip_path | default('/tmp/metabase_db.sql.zip') }}"
    mode: '0644'

# Extract into /tmp (idempotent if the .sql already exists)
- name: Unzip SQL dump
  ansible.builtin.unarchive:
    src: "{{ sql_zip_path | default('/tmp/metabase_db.sql.zip') }}"
    dest: "{{ sql_extract_dir | default('/tmp') }}"
    remote_src: true
    creates: "{{ sql_extract_dir | default('/tmp') }}/metabase_db.sql"

# If the archive layout is different, find the actual .sql file
- name: Find unzipped SQL file
  ansible.builtin.find:
    paths: "{{ sql_extract_dir | default('/tmp') }}"
    patterns: "metabase_db.sql"
    file_type: file
  register: found_sql

- name: Fail if SQL file not found after unzip
  ansible.builtin.assert:
    that:
      - found_sql.files | length > 0
    fail_msg: "metabase_db.sql not found after unarchive. Check archive contents."

- name: Import SQL dump into {{ mb_db_name }}
  community.mysql.mysql_db:
    name: "{{ mb_db_name }}"
    state: import
    target: "{{ found_sql.files[0].path }}"
    login_user: root

# (Optional) clean up the uploaded zip
# - name: Remove uploaded zip
#   file:
#     path: "{{ sql_zip_path | default('/tmp/metabase_db.sql.zip') }}"
#     state: absent

# === Changed section ends here ===

- name: Flush privileges
  shell: "mysql -u root -e 'FLUSH PRIVILEGES;'"
  args:
    executable: /bin/bash
